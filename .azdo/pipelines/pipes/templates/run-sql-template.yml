# ------------------------------------------------------------------------------------------------------------------------
# Pipeline template to run one SQL Script against an existing database
# See https://learn.microsoft.com/en-us/azure/devops/pipelines/targets/azure-sqldb?view=azure-devops&tabs=yaml
# ------------------------------------------------------------------------------------------------------------------------
parameters: 
- name: environmentName
  default:  'DEMO'
- name: sqlFolderName
  default: ''
- name: sqlFileName
  default: ''

# ------------------------------------------------------------------------------------------------------------------------
jobs:
- deployment: Deploy${{ parameters.environmentName }}SQL
  displayName: Initialize ${{ parameters.environmentName }} Deploy SQL
  environment: ${{ parameters.environmentName }}

- job: DeployDB${{ parameters.environmentName }}SQL
  displayName: Deploy ${{ parameters.environmentName }} SQL
  variables:
    - name: environmentNameUpper
      value: ${{ upper(parameters.environmentName) }}
    - name: environmentNameLower
      value: ${{ lower(parameters.environmentName) }}
    - name: sqlServerName
      value: $(sqlServerNamePrefix)${{ lower(parameters.environmentName) }}
    - name: fqdnServerName
      value: $(sqlServerName).database.windows.net
    - name: sqlFullFileName
      value: $(System.DefaultWorkingDirectory)\${{ parameters.sqlFolderName }}${{ parameters.sqlFileName }}
    - name: logFullFileName
      value: $(Build.ArtifactStagingDirectory)\Output\${{ parameters.sqlFileName }}.log
    - name: testFileName1
      value: $(Build.ArtifactStagingDirectory)\Output\Example-Output-1.txt
    - name: testFileName2
      value: $(Build.ArtifactStagingDirectory)\Output\Example-Output-2.txt

  steps:
  - bash: |
      resourceGroupName=$(echo "$(resourceGroupPrefix)_$(environmentNameLower)" | tr '[:upper:]' '[:lower:]')
      echo "resourceGroupName=$resourceGroupName"
      echo "##vso[task.setvariable variable=resourceGroupName]$resourceGroupName"
    displayName: 'Create Variables'
    continueOnError: true

  - bash: |
      echo "resourceGroupName=$(resourceGroupName)"
      echo "serviceConnectionName=$(serviceConnectionName)"
      echo "subscriptionName=$(subscriptionName)"
      echo "sqlServerName=$(sqlServerName)"
      echo "fqdnServerName=$(fqdnServerName)"
      echo "sqlDatabaseName=$(sqlDatabaseName)"
      echo "sqlFullFileName=$(sqlFullFileName)"
      echo "logFullFileName=$(logFullFileName)"

      echo "CMD: Invoke-SqlCmd -ServerInstance '$(fqdnServerName)' -Database '$(sqlDatabaseName)' -AccessToken '$token' -InputFile '$(sqlFullFileName)' [send output to] $(logFullFileName)" 
    displayName: 'Display variables and CMD'
    continueOnError: true

  - task: PowerShell@2
    displayName: Make Output Folder
    inputs:
      targetType: 'inline'
      script: |
        cd $(Build.ArtifactStagingDirectory)
        md Output
        cd Output
        echo "This is where the SQL output would go if it was working right..." > $(testFileName1)
        cd ..
      errorActionPreference: 'continue'
      failOnStderr: false

  - task: CmdLine@2
    inputs:
      script: |
        echo "Directory of Default Working Directory: $(System.DefaultWorkingDirectory)"
        dir $(System.DefaultWorkingDirectory) /s

        echo "Directory of Staging Directory: $(Build.ArtifactStagingDirectory)"
        dir $(Build.ArtifactStagingDirectory) /s
    displayName: 'Display Files'
    continueOnError: true

  # ------------------------------------------------------------------------------------------------------------------------
  ## This seemed to be required, but it works without running the firewall change, maybe because I've got Azure services enabled...?
  # ------------------------------------------------------------------------------------------------------------------------
  # # ERROR: this is failing because I'm getting a subscription does not exist error...!
  # - task: AzurePowerShell@5
  #   displayName: 'Add SQL Firewall Exception'
  #   inputs:
  #     azureSubscription: $(serviceConnectionName)
  #     ScriptType: filePath
  #     ScriptPath: '$(Build.SourcesDirectory)\scripts\SetAzureFirewallRule.ps1'
  #     ScriptArguments: '-ServerName $(sqlServerName) -ResourceGroupName $(resourceGroupName) -SubscriptionName "$(subscriptionName)"'
  #     azurePowerShellVersion: LatestVersion
  #   continueOnError: true

  # ------------------------------------------------------------------------------------------------------------------------
  # If you want to add your own IP to the database for testing...
  # ------------------------------------------------------------------------------------------------------------------------
  # - task: AzureCLI@2
  #   displayName: 'Personal Firewall Rule Update (untested)'
  #   inputs:
  #     azureSubscription: ${{ variables.serviceEndpointName }}
  #     scriptType: 'pscore'
  #     scriptLocation: 'inlineScript'
  #     inlineScript: 'az sql server firewall-rule create --name TestRule --resource-group $(resourceGroupName) --server $(sqlServerName) --end-ip-address 192.168.60.236 --start-ip-address 192.168.60.236'

  # ------------------------------------------------------------------------------------------------------------------------
  # One way of running the SqlCmd utility
  # ------------------------------------------------------------------------------------------------------------------------
  # - task: CmdLine@2
  #   displayName: Run Sqlcmd
  #   inputs:
  #     filename: Sqlcmd
  #     arguments: '-S $(fqdnServerName) -U $(sqlAdminUser) -P $(sqlAdminPassword) -d $(sqlDatabaseName) -i $(sqlFullFileName)'

  # ------------------------------------------------------------------------------------------------------------------------
  # Another way of running the SqlCmd utility
  # ------------------------------------------------------------------------------------------------------------------------
  - task: AzurePowerShell@5
    displayName: Run Invoke-SqlCmd
    inputs:
      azureSubscription: $(serviceConnectionName)
      azurePowerShellVersion: 'LatestVersion'
      scriptType: inlinescript
      script: |
          $token = (Get-AzAccessToken -ResourceUrl https://database.windows.net).Token
          $cmdOutput = & (cmd /c Invoke-SqlCmd -ServerInstance "$(fqdnServerName)" -Database "$(sqlDatabaseName)" -AccessToken "$token" -InputFile "$(sqlFullFileName)" -verbose) 2>&1 | Out-String
          echo $cmdOutput
          echo $(logFullFileName)
          echo $cmdOutput > output.log
          echo $cmdOutput > $(logFullFileName)
          echo "Another file test..." > $(testFileName2)

    # try a & in front of command    > $cmdOutput = & Invoke-SqlCmd...  2>1 | Out-String
    # try this:   $cmdOutput = (cmd /c Invoke-SqlCmd... 2`>`&1)
    # Invoke-SqlCmd -ServerInstance "$(fqdnServerName)" -Database "$(sqlDatabaseName)" -AccessToken "$token" -InputFile "$(sqlFullFileName)" 2>&1 > $(logFullFileName) 
    # (Invoke-SqlCmd -ServerInstance "$(fqdnServerName)" -Database "$(sqlDatabaseName)" -AccessToken "$token" -InputFile "$(sqlFullFileName)" -verbose) 4>&1 > $(logFullFileName) 

  # ------------------------------------------------------------------------------------------------------------------------
  ## This seemed to be required, but it works without running the firewall change, maybe because I've got Azure services enabled...?
  # ------------------------------------------------------------------------------------------------------------------------
  # - task: AzurePowerShell@5
  #   displayName: 'Remove SQL Firewall Exception'
  #   inputs:
  #     azureSubscription: $(serviceConnectionName)
  #     ScriptType: filePath
  #     ScriptPath: '$(Build.SourcesDirectory)\scripts\RemoveAzureFirewallRule.ps1'
  #     ScriptArguments: '-ServerName $(sqlServerName) -ResourceGroupName $(resourceGroupName)'
  #     azurePowerShellVersion: LatestVersion

  - task: CmdLine@2
    inputs:
      script: |
        echo "Directory of Staging Directory: $(Build.ArtifactStagingDirectory)"
        dir $(Build.ArtifactStagingDirectory) /s

        echo "Directory of Temp Directory: D:\a\_temp\"
        dir D:\a\_temp\ /s
    displayName: 'Display Post Run Files'
    continueOnError: true

  # - task: PowerShell@2
  #   displayName: Copy Output Folder
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       cd $(Build.ArtifactStagingDirectory)/packages
  #       cd Deploy
  #       md Linux
  #       cd ..
  #       move $(folderName)/$(exeName) $(Build.ArtifactStagingDirectory)/packages/Deploy/Linux/
  #     errorActionPreference: 'continue'
  #     failOnStderr: false

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Output Artifacts'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)/Output'
      ArtifactName: 'Output'