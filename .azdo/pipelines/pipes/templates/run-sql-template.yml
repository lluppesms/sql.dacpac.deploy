# ------------------------------------------------------------------------------------------------------------------------
# Pipeline template to run one SQL Script against an existing database
# See https://learn.microsoft.com/en-us/azure/devops/pipelines/targets/azure-sqldb?view=azure-devops&tabs=yaml
# ------------------------------------------------------------------------------------------------------------------------
# WARNING: This seems to run successfully, but I can't verify that it actually works!
# I've tried many ways of capturing the output of the Invoke-SqlCmd command, but it doesn't seem to work.
# ------------------------------------------------------------------------------------------------------------------------
parameters: 
- name: environmentName
  default:  'DEMO'
- name: sqlFolderName
  default: ''
- name: sqlFileName
  default: ''

# ------------------------------------------------------------------------------------------------------------------------
jobs:
- deployment: Deploy${{ parameters.environmentName }}SQL
  displayName: Initialize ${{ parameters.environmentName }} Deploy SQL
  environment: ${{ parameters.environmentName }}

- job: DeployDB${{ parameters.environmentName }}SQL
  displayName: Deploy ${{ parameters.environmentName }} SQL
  variables:
    - name: environmentNameUpper
      value: ${{ upper(parameters.environmentName) }}
    - name: environmentNameLower
      value: ${{ lower(parameters.environmentName) }}
    - name: sqlServerName
      value: $(sqlServerNamePrefix)${{ lower(parameters.environmentName) }}
    - name: fqdnServerName
      value: $(sqlServerName).database.windows.net
    - name: sqlFullFileName
      value: $(System.DefaultWorkingDirectory)\${{ parameters.sqlFolderName }}${{ parameters.sqlFileName }}
    - name: logFullFileName
      value: $(Build.ArtifactStagingDirectory)\Output\${{ parameters.sqlFileName }}.log
    - name: testFileName1
      value: $(Build.ArtifactStagingDirectory)\Output\Example-Output-1.txt
    - name: testFileName2
      value: $(Build.ArtifactStagingDirectory)\Output\Example-Output-2.txt

  steps:
  - bash: |
      resourceGroupName=$(echo "$(resourceGroupPrefix)_$(environmentNameLower)" | tr '[:upper:]' '[:lower:]')
      echo "resourceGroupName=$resourceGroupName"
      echo "##vso[task.setvariable variable=resourceGroupName]$resourceGroupName"
    displayName: 'Create Variables'
    continueOnError: true

  - task: PowerShell@2
    displayName: Make Output Folder
    inputs:
      targetType: 'inline'
      script: |
        cd $(Build.ArtifactStagingDirectory)
        md Output
        cd Output
        echo "Dummy file to create one output..." > $(testFileName1)
        cd ..
      errorActionPreference: 'continue'
      failOnStderr: false

  - bash: |
      echo "resourceGroupName=$(resourceGroupName)"
      echo "serviceConnectionName=$(serviceConnectionName)"
      echo "subscriptionName=$(subscriptionName)"
      echo "sqlServerName=$(sqlServerName)"
      echo "fqdnServerName=$(fqdnServerName)"
      echo "sqlDatabaseName=$(sqlDatabaseName)"
      echo "sqlFullFileName=$(sqlFullFileName)"
      echo "logFullFileName=$(logFullFileName)"
      echo "CMD: Invoke-SqlCmd -ServerInstance '$(fqdnServerName)' -Database '$(sqlDatabaseName)' -AccessToken '$token' -InputFile '$(sqlFullFileName)'" 
    displayName: 'Display variables and CMD'
    continueOnError: true

  - task: CmdLine@2
    inputs:
      script: |
        echo "Directory of Default Working Directory: $(System.DefaultWorkingDirectory)"
        dir $(System.DefaultWorkingDirectory) /s

        echo "Directory of Staging Directory: $(Build.ArtifactStagingDirectory)"
        dir $(Build.ArtifactStagingDirectory) /s
    displayName: 'Display Files'
    continueOnError: true

  # ------------------------------------------------------------------------------------------------------------------------
  ## This seemed to be required, but it works without running the firewall change, maybe because I've got Azure services enabled...?
  # ------------------------------------------------------------------------------------------------------------------------
  # # ERROR: this is failing because I'm getting a subscription does not exist error...!
  # - task: AzurePowerShell@5
  #   displayName: 'Add SQL Firewall Exception'
  #   inputs:
  #     azureSubscription: $(serviceConnectionName)
  #     ScriptType: filePath
  #     ScriptPath: '$(Build.SourcesDirectory)\scripts\SetAzureFirewallRule.ps1'
  #     ScriptArguments: '-ServerName $(sqlServerName) -ResourceGroupName $(resourceGroupName) -SubscriptionName "$(subscriptionName)"'
  #     azurePowerShellVersion: LatestVersion
  #   continueOnError: true

  # ------------------------------------------------------------------------------------------------------------------------
  # If you want to add your own IP to the database for testing...
  # ------------------------------------------------------------------------------------------------------------------------
  # - task: AzureCLI@2
  #   displayName: 'Personal Firewall Rule Update (untested)'
  #   inputs:
  #     azureSubscription: ${{ variables.serviceEndpointName }}
  #     scriptType: 'pscore'
  #     scriptLocation: 'inlineScript'
  #     inlineScript: 'az sql server firewall-rule create --name TestRule --resource-group $(resourceGroupName) --server $(sqlServerName) --end-ip-address 192.168.60.236 --start-ip-address 192.168.60.236'

  # ------------------------------------------------------------------------------------------------------------------------
  # Run SqlCmd utility with userid/password
  # ------------------------------------------------------------------------------------------------------------------------
  # - task: CmdLine@2
  #   displayName: Run Sqlcmd
  #   inputs:
  #     filename: Sqlcmd
  #     arguments: '-S $(fqdnServerName) -U $(sqlAdminUser) -P $(sqlAdminPassword) -d $(sqlDatabaseName) -i $(sqlFullFileName)'

  # ------------------------------------------------------------------------------------------------------------------------
  # Run SqlCmd utility with access token
  # ------------------------------------------------------------------------------------------------------------------------
  - task: AzurePowerShell@5
    displayName: Run Invoke-SqlCmd
    inputs:
      azureSubscription: $(serviceConnectionName)
      azurePowerShellVersion: 'LatestVersion'
      scriptType: inlinescript
      script: |
        $token = (Get-AzAccessToken -ResourceUrl https://database.windows.net).Token
        Invoke-SqlCmd -ServerInstance "$(fqdnServerName)" -Database "$(sqlDatabaseName)" -AccessToken "$token" -InputFile "$(sqlFullFileName)" -verbose | Out-File -filePath $(logFullFileName)
    
    # Some things I've tried...
    # $cmdOutput = Invoke-SqlCmd -ServerInstance "$(fqdnServerName)" -Database "$(sqlDatabaseName)" -AccessToken "$token" -InputFile "$(sqlFullFileName)" -verbose | Out-String
    # Write-Verbose "$cmdOutput" -Verbose
    # echo $cmdOutput
    # echo $(logFullFileName)
    # echo $cmdOutput > output.log
    # echo $cmdOutput > $(logFullFileName)
    # echo "Another file test..." > $(testFileName2)
    # Write-Output "##vso[task.setvariable variable=cmdOutput;]$cmdOutput"

  # ------------------------------------------------------------------------------------------------------------------------
  ## This seemed to be required, but it works without running the firewall change, maybe because I've got Azure services enabled...?
  # ------------------------------------------------------------------------------------------------------------------------
  # - task: AzurePowerShell@5
  #   displayName: 'Remove SQL Firewall Exception'
  #   inputs:
  #     azureSubscription: $(serviceConnectionName)
  #     ScriptType: filePath
  #     ScriptPath: '$(Build.SourcesDirectory)\scripts\RemoveAzureFirewallRule.ps1'
  #     ScriptArguments: '-ServerName $(sqlServerName) -ResourceGroupName $(resourceGroupName)'
  #     azurePowerShellVersion: LatestVersion

  - task: CmdLine@2
    inputs:
      script: |
        echo "Directory of Staging Directory: $(Build.ArtifactStagingDirectory)"
        dir $(Build.ArtifactStagingDirectory) /s
        echo "Directory of Temp Directory: D:\a\_temp\"
        dir D:\a\_temp\ /s
    displayName: 'List Output Files'
    continueOnError: true

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Output Artifacts'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)/Output'
      ArtifactName: 'Output'